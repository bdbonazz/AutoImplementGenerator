using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace ClassLibrary2;
#nullable enable
[Generator]
public class AutoImplementGenerator : IIncrementalGenerator
{
    private const string AttributeNameSpace = "AttributeGenerator";
    private const string AttributeName = "AutoImplementProperties";
    private const string AttributeClassName = $"{AttributeName}Attribute";
    private const string FullyQualifiedAttributeName = $"{AttributeNameSpace}.{AttributeClassName}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            //Generate the AutoImplementProperties Attribute
            const string autoImplementAttributeDeclarationCode = $$"""
// <auto-generated/>
using System;
namespace {{AttributeNameSpace}};

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
sealed class {{AttributeClassName}} : Attribute
{
    public Type[] InterfacesTypes { get; }
    public {{AttributeClassName}}(params Type[] interfacesTypes)
    {
        InterfacesTypes = interfacesTypes;
    }
}
""";
            ctx.AddSource($"{AttributeClassName}.g.cs", autoImplementAttributeDeclarationCode);
        });

        IncrementalValuesProvider<ClassModel> provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: FullyQualifiedAttributeName,
            predicate: static (node, cancellationToken_) => node is ClassDeclarationSyntax,
            transform: static (ctx, cancellationToken) =>
            {
                ISymbol classSymbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!;

                return new ClassModel(
                    classSymbol.Name,
                    classSymbol.ContainingNamespace.ToDisplayString(),
                    GetInterfaceModels(classSymbol)
                    );
            }).Where(m => m is not null);

        context.RegisterSourceOutput(provider, static (context, classModel) =>
        {
            foreach (InterfaceModel interfaceModel in classModel.Interfaces)
            {
                StringBuilder sourceBuilder = new($$"""
                    // <auto-generated/>
                    namespace {{classModel.NameSpace}};

                    public partial class {{classModel.Name}} : {{interfaceModel.FullyQualifiedName}}
                    {

                    """);

                foreach (string property in interfaceModel.Properties)
                {
                    sourceBuilder.AppendLine(property);
                }

                sourceBuilder.AppendLine("""
                    }
                    """);

                //Concat class name and interface name to have unique file name if a class implements two interfaces with AutoImplement Attribute
                string generatedFileName = $"{classModel.Name}_{interfaceModel.FullyQualifiedName}.g.cs";
                context.AddSource(generatedFileName, sourceBuilder.ToString());
            }
        });
    }

    private static EquatableList<InterfaceModel> GetInterfaceModels(ISymbol classSymbol)
    {
        EquatableList<InterfaceModel> ret = [];

        AttributeData attribute = classSymbol.GetAttributes().First(a => a.AttributeClass!.Name == AttributeClassName);
        INamedTypeSymbol[] interfaceSymbols = attribute.ConstructorArguments[0].Values.Select(x => (x.Value as INamedTypeSymbol)!).ToArray();
        foreach (INamedTypeSymbol interfaceSymbol in interfaceSymbols)
        {
            EquatableList<string> properties = new();

            foreach (IPropertySymbol interfaceProperty in interfaceSymbol
                .GetMembers()
                .OfType<IPropertySymbol>())
            {
                string type = interfaceProperty.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                //Check if property has a setter
                string setter = interfaceProperty.SetMethod is not null
                    ? "set; "
                    : string.Empty;

                properties.Add($$"""
                            public {{type}} {{interfaceProperty.Name}} { get; {{setter}}}
                        """);
            }

            ret.Add(new InterfaceModel(interfaceSymbol.ToDisplayString(), properties));
        }

        return ret;
    }

    private record ClassModel(string Name, string NameSpace, EquatableList<InterfaceModel> Interfaces);
    private record InterfaceModel(string FullyQualifiedName, EquatableList<string> Properties);

    private class EquatableList<T> : List<T>, IEquatable<EquatableList<T>>
    {
        public bool Equals(EquatableList<T>? other)
        {
            // If the other list is null or a different size, they're not equal
            if (other is null || Count != other.Count)
            {
                return false;
            }

            // Compare each pair of elements for equality
            for (int i = 0; i < Count; i++)
            {
                if (!EqualityComparer<T>.Default.Equals(this[i], other[i]))
                {
                    return false;
                }
            }

            // If we got this far, the lists are equal
            return true;
        }
        public override bool Equals(object obj)
        {
            return Equals(obj as EquatableList<T>);
        }
        public override int GetHashCode()
        {
            return this.Select(item => item?.GetHashCode() ?? 0).Aggregate((x, y) => x ^ y);
        }
        public static bool operator ==(EquatableList<T> list1, EquatableList<T> list2)
        {
            return ReferenceEquals(list1, list2)
                || list1 is not null && list2 is not null && list1.Equals(list2);
        }
        public static bool operator !=(EquatableList<T> list1, EquatableList<T> list2)
        {
            return !(list1 == list2);
        }
    }
}
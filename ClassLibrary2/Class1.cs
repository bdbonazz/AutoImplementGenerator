using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ClassLibrary2;
#nullable enable
[Generator]
public class AutoImplementGenerator : IIncrementalGenerator
{
    private const string AttributeNameSpace = "AttributeGenerator";
    private const string AttributeName = "AutoImplementProperties";
    private const string AttributeClassName = $"{AttributeName}Attribute";
    private const string FullyQualifiedAttributeName = $"{AttributeNameSpace}.{AttributeClassName}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            //Generate the AutoImplementProperties Attribute
            const string autoImplementAttributeDeclarationCode = $$"""
// <auto-generated/>
using System;
namespace {{AttributeNameSpace}};

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
sealed class {{AttributeClassName}} : Attribute
{
    public Type[] InterfacesTypes { get; }
    public {{AttributeClassName}}(params Type[] interfacesTypes)
    {
        InterfacesTypes = interfacesTypes;
    }
}
""";
            ctx.AddSource($"{AttributeClassName}.g.cs", autoImplementAttributeDeclarationCode);
        });

        IncrementalValuesProvider<ClassModel> provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: FullyQualifiedAttributeName,
            predicate: static (node, cancellationToken_) => node is ClassDeclarationSyntax,
            transform: static (ctx, cancellationToken) =>
            {
                ISymbol classSymbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!;

                return new ClassModel(
                    classSymbol.Name,
                    classSymbol.ContainingNamespace.ToDisplayString(),
                    GetInterfaceModels(classSymbol)
                    );
            }).Where(m => m is not null);

        context.RegisterSourceOutput(provider, static (context, classModel) =>
        {
            foreach (InterfaceModel interfaceModel in classModel.Interfaces)
            {
                StringBuilder sourceBuilder = new($$"""
                    // <auto-generated/>
                    namespace {{classModel.NameSpace}};

                    partial class {{classModel.Name}} : {{interfaceModel.FullyQualifiedName}}
                    {

                    """);

                foreach (string property in interfaceModel.Properties)
                {
                    sourceBuilder.AppendLine(property);
                }

                sourceBuilder.AppendLine("""
                    }
                    """);

                //Concat class name and interface name to have unique file name if a class implements two interfaces with AutoImplement Attribute
                string generatedFileName = $"{classModel.Name}_{interfaceModel.FullyQualifiedName}.g.cs";
                context.AddSource(generatedFileName, sourceBuilder.ToString());
            }
        });
    }

    private static InterfaceModel[] GetInterfaceModels(ISymbol classSymbol)
    {
        List<InterfaceModel> ret = [];

        AttributeData attribute = classSymbol.GetAttributes().First(a => a.AttributeClass!.Name == AttributeClassName);
        INamedTypeSymbol[] interfaceSymbols = attribute.ConstructorArguments[0].Values.Select(x => (x.Value as INamedTypeSymbol)!).ToArray();
        foreach (INamedTypeSymbol interfaceSymbol in interfaceSymbols)
        {
            string[] propertyModels = interfaceSymbol
                .GetMembers()
                .OfType<IPropertySymbol>()
                .Select(interfaceProperty =>
                {
                    string type = interfaceProperty.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    //Check if property has a setter
                    string setter = interfaceProperty.SetMethod is not null
                        ? "set; "
                        : string.Empty;

                    return $$"""
                            public {{type}} {{interfaceProperty.Name}} { get; {{setter}}}
                        """;
                })
                .ToArray();

            ret.Add(new InterfaceModel(interfaceSymbol.ToDisplayString(), propertyModels));
        }

        return [.. ret];
    }

    private record ClassModel(string Name, string NameSpace, InterfaceModel[] Interfaces);
    private record InterfaceModel(string FullyQualifiedName, string[] Properties);
}